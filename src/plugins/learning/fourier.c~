/**
 * This file learns an event as a fourier serie function.
 **/

#include <hmon.h>
#include <string.h>
#include <math.h>
#include "learning.h"

#define N           64      /* Harmonics */
#define PHI         0.0     /* Phase     */
#define T           1.0     /* Periode   */

struct brain{
    struct perceptron * p;
    double * X;
    double * Y;
    double * S;
};

/**
 * Create a perceptron with n features and n samples.
 * @param n: the number of features.
 * @param m: the number of samples.
 * @return a brain holding a perceptron to learn, a matrix of features and a unit array.
 **/
struct brain * new_brain(const int n, const int m){
    struct brain * b = malloc(sizeof(*b));
    b->p = new_perceptron(n);
    b->X = malloc(sizeof(double) * (n) * m);
    b->Y = malloc(sizeof(double) * m);
    b->S = Unit(m);
    return b;
}


static void fourier_features(struct monitor * hmon){
    unsigned       c = hmon->current;
    unsigned       m = hmon->n_samples;	
    long           t = hmon->timestamps[c];
    double *       Y = hmon->samples;
    long           l = hmon->timestamps[c] - hmon->timestamps[(c-1)%m];
    
    /* Compute c0 */
    X[0] = 0;
    for(unsigned i=0; i<m; i++){
    	X[0] += Y[i];
    }
    X[0] = X[0] / l;
    
    for(unsigned i=1; i<n; i++){
	X[i] = cos(2*M_PI*i*t/T + PHI);
    }
	
    printf("X = (");
    for(unsigned i = 0; i<n; i++)
	printf("%f, ", X[i]);
    printf(")\n");
}

/**
 * Predict next sample by fitting a fourier serie.
 * Function to be used as field SAMPLES_REDUCE in monitor definition.
 **/
double fourier_fit(struct monitor * hmon){
    unsigned       c = hmon->current;
    unsigned       m = hmon->n_samples;
    const int      n = N+1;

    /* store data structure in monitor */
    if(hmon->userdata == NULL){
	hmon->userdata = new_brain(n, m);
    }
    
    struct brain * b = hmon->userdata;
    double * X = b->X;
    double prediction;

    /* Set features */
    fourier_features(&(X[n*c]), hmon->samples, hmon->timestamps, hmon->timestamps[c], n);

    /* Train only for a significant amount of samples */
    if(hmon->current == m-1){			       
	memcpy(b->Y, hmon->samples, m * sizeof(double));
	printf("prediciton on %s:%d\n", hwloc_type_name(hmon->location->type), hmon->location->logical_index);
	/* perceptron_fit_by_normal_equation(b->p, X, b->Y, b->S, m); */
	perceptron_fit_by_gradiant_descent(b->p, X, b->Y, m);
	/* Reset X to its value */
	fourier_features(&(X[n*c]), hmon->samples, hmon->timestamps, hmon->timestamps[c], n);
    }
    
    /* Predict */
    prediction = perceptron_output(b->p, &(X[n*c]));
    /* Output absolute difference between prediciton and true value */
    return prediction; /* 100 * fabs(prediction + hmon->samples[c])/fabs(hmon->samples[c]+prediction); */
}

