#!/usr/bin/Rscript

library("optparse")
source("./nmeans.R")

#Parse options
inOpt=make_option(opt_str=c("-i", "--input"), type="character", default=NULL, help="Data set input file")

outOpt=make_option(opt_str=c("-o", "--output"), type="character", default=NULL, help="Output pdf file (static)")

titleOpt=make_option(opt_str=c("-t", "--title"), type="character", default=NULL, help="Plot title")

grepOpt=make_option(opt_str=c("-g", "--grep"), type="character",default=NULL, help="Provide a regex to filter input monitor base on their id (first column)")

logOpt=make_option(opt_str=c("-l", "--log"), type="logical", default=FALSE, action="store_true", help="logscale graph")

colOpt=make_option(opt_str=c("-y", "--column"), type="integer", default=4, help="Use column --column instead of column 4 as Y values to plot")

splitOpt=make_option(opt_str=c("-s", "--split"), type="logical", default=FALSE,action="store_true", help="split one plot per monitor")

clusterOpt=make_option(opt_str=c("-c", "--cluster"), type="logical", default=FALSE, ,action="store_true", help="cluster input data and plot with different colors")

histOpt=make_option(opt_str=c("-d", "--distribution"), type="logical", default=FALSE,action="store_true", help="plot histogram of values distribution instead of values")

fitOpt=make_option(opt_str=c("-f", "--fit"), type="character", default=NULL, help="fit y data. If (--if = \"events\"), then use a linear model of events to fit --column column, and output cross validation points. If (--if = \"fourier\"), fit y columns with a fourier serie of time column")

winOpt=make_option( opt_str=c("-w", "--window"), type="integer", default=1000, help="number of points to plot (dynamic)")

updateOpt=make_option(opt_str=c("-u", "--update"), type="numeric", default=0, help="frequency of read from trace file and plot in seconds. Plot should be displayed as parts of a large or updated trace. In this case --window points will be plot and window will move by --window/4 steps ahead every --update seconds")

option_list=c(inOpt, outOpt, titleOpt, grepOpt, logOpt, colOpt, splitOpt, clusterOpt, histOpt, fitOpt, winOpt, updateOpt)
opt_parser=OptionParser(option_list=option_list)

#Functions
lseq =function(from=1, to=100000, length.out=6) {
    exp(seq(log(from), log(to), length.out=length.out))
}

read_monitors=function(frame, connexion) {
  lines=readLines(connexion, n=options$window/4)
  for (line in lines) {
    frame_line=read.table(textConnection(line), flush=T)
    if (is.null(options$grep) || frame_line[1, 1] == options$grep) {
      frame=rbind(frame, frame_line)
    }
  }
  if (options$update>0 && nrow(frame) > options$window) {
    frame=frame[(nrow(frame)-options$window):nrow(frame), ]
  }
  frame
}

get_title <- function(){
 if(!is.null(options$title)){options$title} else if(!is.null(options$restrict)){options$restrict} else {options$input}
}

lm_fit <- function(data, col=1, cex=.4, pch=2){
  if(ncol(data)<5){
     warning(sprintf("monitor %s must have at least 5 columns, column 4 is target fit, and next columns are input parameters", data[1,1]))
     stop()
  }
  fit.range=sample(1:nrow(data), round(0.5 * nrow(data)))
  fit.range=fit.range[order(fit.range)]
  #data[,4]=rnorm(nrow(data), mean=mean(data[,4]),sd=sd(data[,4]))

  x.pred=data[-fit.range, 3]
  X.fit =data[fit.range, 5:ncol(data)]
  Y.fit =data[fit.range, 4]
  X.pred=data[-fit.range, 5:ncol(data)]
  Y.pred=data[-fit.range, 4]

  #linear model fit
  lm.fit=lm(Y.fit ~ ., data=X.fit)
  lm.pred=predict(lm.fit, newdata=X.pred)

  points(x.pred, abs(lm.pred-Y.pred), pch=pch, col=col, cex=cex)
  
  #neural network fit
  # library(neuralnet)
  # scaleX=scale(X.fit)
  # X.fit.scale=as.data.frame(scaleX)
  # Y.fit.scale=scale(Y.fit)
  # X.pred.scale=(X.pred - attr(scaleX, "scaled:center")) / attr(scaleX, "scaled:scale")
  # n <- names(X.fit.scale)
  # f <- as.formula(paste("Y.fit.scale ~", paste(n, collapse="+")))
  # nn <- neuralnet(f, data=X.fit.scale, hidden=c(2, 1), linear.output=T)
  # nn.pred=compute(nn, X.pred.scale)
  # Y.pred.scale=nn.pred$net.result
  # nn.pred=Y.pred.scale * attr(Y.fit.scale, "scaled:scale") + attr(Y.fit.scale, "scaled:center")
}

fourier_fit <- function(data, col=1, cex=.4, pch=-1){
  T=(data[,3][nrow(data)]-data[,3][1])/nrow(data)
  K=2*pi/T
  H=1:8
  harmonics=paste(c("data[,4]~1", as.vector(sapply(H,function(n){paste("cos(",(n*K),"*data[,3])")}))), collapse="+")
  model=as.formula(harmonics)
  fit=lm(model, data=data);
  pred=predict(fit)
  points(data[,3], abs(pred-data[,4]), pch=pch, col=col, cex=cex)
}

histogram_monitor=function(frame, ylim=NULL, col=1){
  obj=frame[1,2];  monitor=frame[1,1];
  if(options$split){
    ylim=c(min(frame[, 4],  na.rm=TRUE), max(frame[, 4],  na.rm=TRUE))
    title=sprintf("histogram of monitor %s on %s", monitor, obj)
    xlab=monitor
    plot(hist(frame[, 4], n=100, plot=FALSE), xlab=monitor, xlim=ylim, col=col, main=title)
  } else {
    hist(frame[, 4], n=100, xlab="", ylab="", main="")
  }
  if(options$split){par(new=TRUE)}
}

plot_monitor=function(frame, split=FALSE, cluster=FALSE, ylim=NULL, xlim=NULL, ann=FALSE, ylog=FALSE, col=1, cex=.4, legend=NULL){
  # prepare plot
  if(is.null(ylim)) ylim=c(min(frame[, 4],  na.rm=TRUE), max(frame[, 4],  na.rm=TRUE))
  if(is.null(xlim)) xlim=c( min(frame[, 3], na.rm=TRUE), max(frame[, 3], na.rm=TRUE))
  xticks=seq(xlim[1], xlim[2], (xlim[2] - xlim[1]) / 10)
  if(is.null(legend)){legend=as.character(frame[1,2])}
  pch=col
  if(ylog){
    ylim=c(max(ylim[1],1), max(ylim[2],1))
    yticks=lseq(from=ylim[1], to=ylim[2], length.out=log10(ylim[2] / ylim[1]))
  }
  else{yticks=seq(from=ylim[1], to=ylim[2], by=(ylim[2] - ylim[1]) / 10)}

  #check whether we apply clustering
  if(cluster){
    points=scale(frame[,4], center=TRUE, scale=TRUE)
    points[1]=points[1]*(ncol(frame)-3)
    km=nmeans(x=points)
    col=km$cluster
    for(i in 1:nrow(km$centers)){
      plot_monitor(frame[which(col==i),], split=split, cluster=FALSE, ann=ann, ylim=ylim, xlim=xlim, ylog=ylog, col=i, cex=cex, legend=sprintf("cluster:%d %s", i, legend[1]))
    }
    return()
  }

  #plot
  obj=frame[1,2];  monitor=frame[1,1];
  plot(x=frame[,3],
       y=frame[,4],
       main=title,
       ylog=ylog,
       type='p',
       col=col,
       xlim=xlim,
       ylim=ylim,
       axes=FALSE,
       ann=FALSE,
       pch=pch,
       panel.first=abline(h=yticks, v=xticks, col="darkgray",lty=3),
       cex=cex)

  if(!is.null(options$fit) && options$fit == "fourier"){
    fourier_fit(frame, col=2, pch=10)
    legend=c(legend, "abs.err fourier fit")
    pch=c(pch,10)
    col=c(col,2)
  }
  if(!is.null(options$fit) && options$fit == "events"){
    lm_fit(frame, col=1, pch=2)
    legend=c(legend, "abs.err events fit")
    pch=c(pch,2)
    col=c(col,1)      
  }
  if(ann){
    axis(1, at=xticks, labels=xticks)
    axis(2, at=yticks, labels=yticks)
    title(main=get_title(), xlab="nanoseconds", ylab=sprintf("%s", frame[1,1]))
    legend("bottomright", col=col, legend=legend, pch=pch,bg="white")
  }
  if(!split){par(new=TRUE)}
}

plot_monitors <- function(frame){
  par(ann=FALSE)
  if(ncol(frame) == 4){frame=frame[is.finite(frame[, 4]),]}
  else{frame=frame[is.finite(rowSums(frame[, 4:ncol(frame)])),]}
  if(options$column != 4) frame=swap_cols(frame,4,options$column)
  if(!options$split){
    xlim=c(min(frame[, 3], na.rm=TRUE), max(frame[, 3], na.rm=TRUE))
    ylim=c(min(frame[, 4],  na.rm=TRUE), max(frame[, 4],  na.rm=TRUE))
    if(options$log){ylim=c(max(ylim[1],1), max(ylim[2],1))}
  } else {ylim=NULL; xlim=NULL;}
  
  monitors=unique(frame[, c(1,2)])
  monitors=monitors[order(monitors[,1]),]
  objs=monitors[,2]
  names=monitors[,1]
  
  for (i in 1:nrow(monitors)) {
    data=subset(frame, frame[, 2] == objs[i] & frame[,1] == names[i])
    if(options$distribution){histogram_monitor(data, ylim=xlim, col=i)} 
    else{plot_monitor(data, options$split, options$cluster, xlim=xlim, ylim=ylim, ann=options$split, ylog=options$log, col=i);}
  }
  if(!options$split){
     legend=paste(objs,names,sep=" ")
     col=1:length(objs)
     pch=1:length(objs)
     if(!is.null(options$fit)){
       legend = c(legend, "abs.err fit")
       col = c(col, 2)
       pch = c(pch, 10)
     }
     legend("bottomright", legend=legend, cex=.7, col=col, pch=pch, bg="white")
     if(options$distribution){
       xlab="monitors value"
       ylab="frequency"
     } else {
       xlab="nanoseconds"
       ylab="monitors value"
     }
     xticks=seq(xlim[1], xlim[2], (xlim[2] - xlim[1]) / 10)
     if(options$log == FALSE){yticks=seq(from=ylim[1], to=ylim[2], by=(ylim[2] - ylim[1]) / 10)}
     else{yticks=lseq(from=ylim[1], to=ylim[2], length.out=log10(ylim[2] / ylim[1]))} 
     title(main=get_title(), ylab=ylab, xlab=xlab)
     axis(1, at=xticks)
     axis(2, at=yticks)
  }
}

#Script
options=parse_args(opt_parser, args=commandArgs(trailingOnly=TRUE), print_help_and_exit=TRUE, positional_arguments=FALSE)

#Ask input if not provided in options
if(is.null(options$input)) stop("Input options is compulsory");


#Check output
if (!is.null(options$output) && options$update>0) {
  stop(
    "Options --output and --update cannot be set simultaneously. Whether you plot statically the whole file, or you plot updated file dynamically.",
    call.=FALSE
  )
}

if (is.null(options$output) && !options$update>0) {
  options$output=paste(options$input, "pdf", sep=".")
  print(sprintf("Output to %s", options$output))
}

swap_cols <- function(frame, i,j){
  tmp=frame[,i]
  frame[,i]=frame[,j]
  frame[,j]=tmp
  frame
}

if (!options$update>0) {
  pdf(options$output, family="Helvetica", width=10, height=5, title=options$file)
  frame=read.table(options$input)
  plot_monitors(frame);
  graphics.off()
} else {
  df=data.frame(name=character(0), obj=character(0), nano=numeric(0), val=numeric(0))
  stream=fifo(options$input, open="r")
  x11(xpos=0, ypos=0)
  df=read_monitors(df, stream)
  if(options$split){
     par(mfrow=c(length(unique(df[,c(1:2)])),1), mar=rep(2,4))	
  }
  repeat {
    plot_monitors(df)
    Sys.sleep(options$update)
    df=read_monitors(df, stream)
  }
}

