#!/usr/bin/Rscript

library("optparse")

#Parse options
inOpt = make_option(opt_str = c("-i", "--input"), type = "character", default = NULL, help = "Data set input file")
outOpt = make_option(opt_str = c("-o", "--output"), type = "character", default = NULL, help = "Output pdf file (static)")
titleOpt = make_option(opt_str = c("-t", "--title"), type = "character", default = NULL, help = "Plot title")
grepOpt = make_option(opt_str = c("-g", "--grep"), type = "character",default = NULL, help = "Provide a regex to filter input monitor base on their id (first column)")
logOpt = make_option(opt_str = c("-l", "--log"), type = "logical", default = FALSE, action = "store_true", help = "logscale graph")
colOpt = make_option(opt_str = c("-y", "--column"), type = "integer", default = 4, help = "Use column --column instead of column 4 as Y values to plot")
splitOpt = make_option(opt_str = c("-s", "--split"), type = "logical", default = FALSE,action = "store_true", help = "split one plot per monitor")
clusterOpt = make_option(opt_str = c("-c", "--cluster"), type = "integer", default = 1, help = "If split option is enabled, compute two clusters and colorize plot with a color per cluster")
histOpt = make_option(opt_str = c("-p", "--histogram"), type = "logical", default = FALSE,action = "store_true", help = "plot histogram of values distribution instead of values")
fitOpt = make_option(opt_str = c("-f", "--fit"), type = "logical", default = FALSE,action = "store_true", help = "fit data with different models and plot cross validation set")
winOpt = make_option( opt_str = c("-w", "--window"), type = "integer", default = 1000, help = "number of points to plot (dynamic)")
updateOpt = make_option(opt_str = c("-u", "--update"), type = "numeric", default = 1, help = "frequency of read from trace file and plot in seconds. (dynamic)")
dynOpt = make_option(opt_str = c("-d", "--dynamic"), type = "logical", default = FALSE, action = "store_true", help = "Set if plot should be displayed as parts of a large trace or updated trace. In this case --window points will be plot and window will move by --window/4 steps ahead every --update seconds")
opt_parser = OptionParser(option_list = c(inOpt, outOpt, grepOpt, logOpt, splitOpt, dynOpt, winOpt, updateOpt, histOpt, fitOpt, colOpt, titleOpt, clusterOpt))

#Functions
lseq =function(from = 1, to = 100000, length.out = 6) {
    exp(seq(log(from), log(to), length.out = length.out))
}

read_monitors = function(frame, connexion) {
  lines = readLines(connexion, n = options$window/4)
  for (line in lines) {
    frame_line = read.table(textConnection(line), flush = T)
    if (is.null(options$grep) || frame_line[1, 1] == options$grep) {
      frame = rbind(frame, frame_line)
    }
  }
  if (options$dynamic && nrow(frame) > options$window) {
    frame = frame[(nrow(frame)-options$window):nrow(frame), ]
  }
  frame
}

get_title <- function(){
 if(!is.null(options$title)){options$title} else if(!is.null(options$restrict)){options$restrict} else {options$input}
}

fit_monitor <- function(data, col=1, xlim=NULL,ylim=NULL){
  fit.range = sample(1:nrow(data), round(0.5 * nrow(data)))
  fit.range = fit.range[order(fit.range)]
  #data[,4] = rnorm(nrow(data), mean = mean(data[,4]),sd = sd(data[,4]))

  x.pred = data[-fit.range, 3]
  X.fit  = data[fit.range, 5:ncol(data)]
  Y.fit  = data[fit.range, 4]
  X.pred = data[-fit.range, 5:ncol(data)]
  Y.pred = data[-fit.range, 4]

  #linear model fit
  lm.fit = lm(Y.fit ~ ., data = X.fit)
  lm.pred = predict(lm.fit, newdata = X.pred)

  #neural network fit
  # library(neuralnet)
  # scaleX = scale(X.fit)
  # X.fit.scale = as.data.frame(scaleX)
  # Y.fit.scale = scale(Y.fit)
  # X.pred.scale = (X.pred - attr(scaleX, "scaled:center")) / attr(scaleX, "scaled:scale")
  # n <- names(X.fit.scale)
  # f <- as.formula(paste("Y.fit.scale ~", paste(n, collapse = "+")))
  # nn <- neuralnet(f, data = X.fit.scale, hidden = c(2, 1), linear.output = T)
  # nn.pred = compute(nn, X.pred.scale)
  # Y.pred.scale = nn.pred$net.result
  # nn.pred = Y.pred.scale * attr(Y.fit.scale, "scaled:scale") + attr(Y.fit.scale, "scaled:center")

  if(options$split){
    width = (max(x.pred)-min(x.pred))*0.125/length(x.pred)
    plot_monitor(data, col = col, ann=TRUE, cex=.8)
    points(x.pred, lm.pred, pch = 2, col = col,cex=.8)
    #points(x.pred, nn.pred, pch = 3, col = col)
    
    # mean = mean(Y.pred - lm.pred)
    # par(new=TRUE)
    # segments(x.pred, y0 = Y.pred-mean/2, y1 = Y.pred+mean/2)
    # par(new=TRUE)
    # segments(x.pred-width, Y.pred-mean/2, x.pred+width, Y.pred-mean/2)
    # par(new=TRUE)
    # segments(x.pred-width, Y.pred+mean/2, x.pred+width, Y.pred+mean/2)
    legend("topright", col = col, legend = c("data to predict", "prediction"), pch = 1:3, bg="white")
  } else {
    par(ann = FALSE)
    if(is.null(xlim)) xlim = c(min(x.pred, na.rm=T), max(x.pred, na.rm=T))
    if(is.null(ylim)) ylim = c(min(Y.pred, lm.pred, na.rm=T), max(Y.pred, lm.pred, na.rm=T))
    plot_monitor(data, col = col, cex=.8)
    points(x.pred, lm.pred, pch = 2, col = col)
    #points(x.pred, nn.pred, pch = 3, col = col)
    legend("topright", col = col, legend = c("data to predict", "prediction"), pch = 1:3, bg="white")
  }
  lm.fit$coefficients
}

histogram_monitor = function(frame, ylim = NULL, col = 1){
  obj = frame[1,2];  monitor = frame[1,1];
  if(options$split){
    ylim = c(min(frame[, 4],  na.rm = TRUE), max(frame[, 4],  na.rm = TRUE))
    title = sprintf("histogram of monitor %s on %s", monitor, obj)
    xlab = monitor
    plot(hist(frame[, 4], n=100, plot=FALSE), xlab=monitor, xlim=ylim, col=col, main=title)
  } else {
    hist(frame[, 4], n=100, xlab="", ylab="", main="")
  }
}

plot_monitor = function(frame, ylim = NULL, xlim=NULL, ann = FALSE, logscale = FALSE, col = 1, cex=1){
  if(is.null(ylim)) ylim = c(min(frame[, 4],  na.rm = TRUE), max(frame[, 4],  na.rm = TRUE))
  if(is.null(xlim)) xlim = c( min(frame[, 3], na.rm = TRUE), max(frame[, 3], na.rm = TRUE))
  xticks = seq(xlim[1], xlim[2], (xlim[2] - xlim[1]) / 10)
  if (logscale == FALSE) {
    yticks = seq(from = ylim[1], to = ylim[2], by = (ylim[2] - ylim[1]) / 10)
  } else {
    ylim = c(max(ylim[1],1), max(ylim[2],1))
    yticks = lseq(from = ylim[1], to = ylim[2], length.out = log10(ylim[2] / ylim[1]))
  }
  if(options$cluster>1){
    points = scale(frame[,3:ncol(frame)], center=TRUE, scale=TRUE)
    points[1] = points[1]*(ncol(frame)-3)
    km = kmeans(x = points, centers = options$cluster, iter.max = 20)
    col = km$cluster
  }

  obj = frame[1,2];  monitor = frame[1,1];
  plot(x = frame[,3],
       y = frame[,4],
       main = title,
       log = if(logscale){"y"} else {""},
       type = 'p',
       col = col,
       xlim = xlim,
       ylim = ylim,
       axes = FALSE,
       ann=FALSE,
       pch = col,
       panel.first = abline(h = yticks, v = xticks, col = "darkgray",lty = 3),
       cex=cex)
  if(ann){
     axis(1, at=xticks, labels=xticks)
     axis(2, at=yticks, labels=yticks)
     title(main = get_title(), xlab = "nanoseconds", ylab = sprintf("%s  %s", frame[1,1], frame[1,2]))
  }
}

plot_monitors <- function(frame){
  par(ann=FALSE)
  if(ncol(frame) == 4){frame = frame[is.finite(frame[, 4]),]}
  else{frame = frame[is.finite(rowSums(frame[, 4:ncol(frame)])),]}
  if(options$column != 4) frame = swap_cols(frame,4,options$column)
  if(!options$split){
    ylim = c(min(frame[, 4],  na.rm = TRUE), max(frame[, 4],  na.rm = TRUE))
    xlim = c(min(frame[, 3], na.rm = TRUE), max(frame[, 3], na.rm = TRUE))
    xticks = seq(xlim[1], xlim[2], (xlim[2] - xlim[1]) / 10)
    if (options$log == FALSE) {
      yticks = seq(from = ylim[1], to = ylim[2], by = (ylim[2] - ylim[1]) / 10)
    } else {
      ylim = c(max(ylim[1],1), max(ylim[2],1))
      yticks = lseq(from = ylim[1], to = ylim[2], length.out = log10(ylim[2] / ylim[1]))
    } 
    title = get_title()
    ann=FALSE
  } else {
    ylim = NULL; xlim = NULL; title = NULL; ann=TRUE
  }
  monitors = unique(frame[, c(1,2)])
  monitors = monitors[order(monitors[,1]),]
  objs = monitors[,2]
  names = monitors[,1]
  for (i in 1:nrow(monitors)) {
    data = subset(frame, frame[, 2] == objs[i] & frame[,1] == names[i])
    if(options$hist) {
      histogram_monitor(data, ylim=xlim, col=i)
    } else if(options$fit) {
      if(ncol(data)<5){
        warning(sprintf("monitor %s must have at least 5 columns, column 4 is target fit, and next columns are input parameters", data[1,1]))
      } else {
      
        coefficients = fit_monitor(data, ylim=ylim, xlim = xlim, col=i)
	ord = order(coefficients*c(1,colMeans(frame[,5:ncol(frame)])), decreasing=TRUE)
	print(data[1,c(1,2)])
        print(ord-1)
        print(coefficients[ord])	
      }
    } else {
      plot_monitor(data, xlim=xlim, ylim=ylim, ann=ann, logscale = options$log, col = i)
    }
    if(!options$split){
      	 par(new = TRUE)
    }
  }

  if(!options$split){
     legend("bottomright", legend=paste(objs,names,sep=" "), cex=.7, col=1:length(objs), pch=1:length(objs))
     if(options$hist){
       xlab="monitors value"
       ylab="frequency"
     } else {
       xlab="nanoseconds"
       ylab="monitors value"
     }
     title(main=get_title(), ylab=ylab, xlab=xlab)
     axis(1, at=xticks)
     axis(2, at=yticks)
  }
}

#Script
options = parse_args(opt_parser, args = commandArgs(trailingOnly = TRUE), print_help_and_exit = TRUE, positional_arguments = FALSE)

#Ask input if not provided in options
if(is.null(options$input)) stop("Input options is compulsory");


#Check output
if (!is.null(options$output) && options$dynamic) {
  stop(
    "Options --output and --dynamic cannot be set simultaneously. Whether you plot statically the whole file, or you plot updated file dynamically.",
    call. = FALSE
  )
}

if (is.null(options$output) && !options$dynamic) {
  options$output = paste(options$input, "pdf", sep = ".")
  print(sprintf("Output to %s", options$output))
}

swap_cols <- function(frame, i,j){
  tmp = frame[,i]
  frame[,i] = frame[,j]
  frame[,j] = tmp
  frame
}

if (!options$dynamic) {
  pdf(options$output, family = "Helvetica", width = 10, height = 5, title=options$file)
  frame = read.table(options$input)
  plot_monitors(frame);
  graphics.off()
} else {
  df = data.frame(name = character(0), obj = character(0), nano = numeric(0), val = numeric(0))
  stream = fifo(options$input, open = "r")
  x11(xpos = 0, ypos = 0)
  df = read_monitors(df, stream)
  if(options$split){
     par(mfrow = c(length(unique(df[,c(1:2)])),1), mar=rep(2,4))	
  }
  repeat {
    plot_monitors(df)
    Sys.sleep(options$update)
    df = read_monitors(df, stream)
  }
}

